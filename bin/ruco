#!/usr/bin/env ruby
# encoding: UTF-8
require 'curses'
require 'optparse'
$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

def parse_options
  options = {}
  parser = OptionParser.new do |opts|
    opts.banner = <<BANNER
[Ru]by [Co]mmandline editor

Shortcuts:
 Ctrl+w/q   Exit
 Ctrl+s     Save

Usage:
    ruco FILE

Options:
BANNER
    opts.on("--debug-cache","Show caching in action") { options[:debug_cache] = true }
    opts.on("--debug-keys", "Show pressed keys") { options[:debug_keys] = true }
    opts.on("-h", "--help","Show this.") { puts opts; exit }
  end
  parser.parse!

  if ARGV.empty?
    puts parser
    exit
  end

  options
end

def write(line,row,text)
  Curses.setpos(line,row)
  Curses.addstr(text);
end

def init_screen
  Curses.noecho # do not show typed chars
  Curses.nonl # turn off newline translation
  Curses.stdscr.keypad(true) # enable arrow keys
  Curses.raw # give us all other keys
  Curses.stdscr.nodelay = 1 # do not block -> we can use timeouts
  Curses.init_screen

  begin
    yield
  ensure
    Curses.close_screen
  end
end

def display(lines, offset, color_mask)
  @screen ||= [] # current screen is used as cache

  lines.each_with_index do |content, line|
    colors = color_mask[line] || []

    # expand line with whitespace
    line += offset
    clearer = Curses.stdscr.maxx - content.size
    clearer = " " * clearer
    content += clearer

    # cache !?
    next if @screen[line] == [content, colors]
    @screen[line] = [content, colors]

    # position at start of line
    index = 0
    Curses.setpos(line,0)
    Curses.attrset(Curses::A_NORMAL)

    # write colored string
    colors.each do |start, color|
      Curses.addstr(content[index...start])
      Curses.attrset color
      index = start
    end
    Curses.addstr(content[index...-1])

    write(line, 0, (rand(899)+100).to_s) if @options[:debug_cache]
  end
end

def show_app(app)
  lines = app.view.naive_split("\n")
  color_mask = app.color_mask

  # TODO move this logic into application
  display([lines.first], 0, [color_mask.first])
  display(lines[1..-2], 1, color_mask[1..-2])
  display([lines.last], Curses.stdscr.maxy - 1, [color_mask.last])

  Curses.setpos(app.cursor.line, app.cursor.column)
end

def debug_key(key)
  @key_line ||= -1
  @key_line = (@key_line + 1) % Curses.stdscr.maxy
  write(@key_line, 0, "#{key}---")
end

def log(stuff)
  File.open('ruco.log','a'){|f| f.puts stuff }
end

@options = parse_options

require 'ruco'

app = Ruco::Application.new(ARGV[0], :lines => Curses.stdscr.maxy, :columns => Curses.stdscr.maxx)

init_screen do
  show_app app

  Keyboard.input do
    Curses.getch
  end

  Keyboard.output do |key|
    debug_key(key) if @options[:debug_keys]
    if key == :resize
      app.resize(Curses.stdscr.maxy, Curses.stdscr.maxx)
      @screen.clear # clear cache
    else
      result = app.key key
    end
    break if result == :quit
    show_app app
  end
end